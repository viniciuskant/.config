"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownlintEngine = void 0;
const coc_nvim_1 = require("coc.nvim");
const deep_extend_1 = __importDefault(require("deep-extend"));
const node_fs_1 = __importDefault(require("node:fs"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const markdownlint_1 = require("markdownlint");
const markdownlint_rule_helpers_1 = require("markdownlint-rule-helpers");
const node_path_1 = __importDefault(require("node:path"));
const rc_1 = __importDefault(require("rc"));
const projectConfigFiles = [".markdownlint.json", ".markdownlint.yaml", ".markdownlint.yml"];
const configFileParsers = [JSON.parse, js_yaml_1.default.load];
class MarkdownlintEngine {
    constructor() {
        this.fixAllCommandName = "markdownlint.fixAll";
        this.source = "markdownlint";
        this.outputChannel = coc_nvim_1.window.createOutputChannel(this.source);
        this.diagnosticCollection = coc_nvim_1.languages.createDiagnosticCollection(this.source);
        this.config = {};
    }
    outputLine(message) {
        if (this.outputChannel) {
            this.outputChannel.appendLine(`[${new Date().toLocaleTimeString()}] ${message}`);
        }
    }
    async parseConfig() {
        try {
            this.config = (0, rc_1.default)(this.source, {});
            this.outputLine(`Info: global config: ${JSON.stringify((0, rc_1.default)(this.source, {}))}`);
        }
        catch (e) {
            this.outputLine(`Error: global config parse failed: ${e}`);
        }
        try {
            for (const projectConfigFile of projectConfigFiles) {
                const fullPath = node_path_1.default.join(coc_nvim_1.workspace.root, projectConfigFile);
                if (node_fs_1.default.existsSync(fullPath)) {
                    // @ts-ignore
                    const projectConfig = (0, markdownlint_1.readConfigSync)(fullPath, configFileParsers);
                    this.config = (0, deep_extend_1.default)(this.config, projectConfig);
                    this.outputLine(`Info: local config: ${fullPath}, ${JSON.stringify(projectConfig)}`);
                    break;
                }
            }
        }
        catch (e) {
            this.outputLine(`Error: local config parse failed: ${e}`);
        }
        const cocConfig = coc_nvim_1.workspace.getConfiguration("markdownlint").get("config");
        if (cocConfig) {
            this.config = (0, deep_extend_1.default)(this.config, cocConfig);
            this.outputLine(`Info: config from coc-settings.json: ${JSON.stringify(cocConfig)}`);
        }
        this.outputLine(`Info: full config: ${JSON.stringify(this.config)}`);
    }
    markdownlintWrapper(document) {
        const options = {
            resultVersion: 3,
            config: this.config,
            // customRules: customRules,
            strings: {
                [document.uri]: document.getText(),
            },
        };
        let results = [];
        try {
            results = (0, markdownlint_1.sync)(options)[document.uri];
        }
        catch (e) {
            this.outputLine(`Error: lint exception: ${e}`);
        }
        return results || [];
    }
    async provideCodeActions(document, range, context) {
        const doc = coc_nvim_1.workspace.getDocument(document.uri);
        const wholeRange = coc_nvim_1.Range.create(0, 0, doc.lineCount, 0);
        let whole = false;
        if (range.start.line === wholeRange.start.line &&
            range.start.character === wholeRange.start.character &&
            range.end.line === wholeRange.end.line &&
            range.end.character === wholeRange.end.character) {
            whole = true;
        }
        const codeActions = [];
        const fixInfoDiagnostics = [];
        for (const diagnostic of context.diagnostics) {
            // @ts-ignore
            if (diagnostic.fixInfo) {
                // @ts-ignore
                const lineNumber = diagnostic.fixInfo.lineNumber - 1 || diagnostic.range.start.line;
                const line = await coc_nvim_1.workspace.getLine(document.uri, lineNumber);
                // @ts-ignore
                const newText = (0, markdownlint_rule_helpers_1.applyFix)(line, diagnostic.fixInfo, "\n");
                const edit = { changes: {} };
                if (typeof newText === "string") {
                    const range = coc_nvim_1.Range.create(lineNumber, 0, lineNumber, line.length);
                    // biome-ignore lint/style/noNonNullAssertion: <explanation>
                    edit.changes[document.uri] = [coc_nvim_1.TextEdit.replace(range, newText)];
                }
                else {
                    // biome-ignore lint/style/noNonNullAssertion: <explanation>
                    edit.changes[document.uri] = [coc_nvim_1.TextEdit.del(diagnostic.range)];
                }
                const title = `Fix: ${diagnostic.message.split(":")[0]}`;
                const action = {
                    title,
                    edit,
                    diagnostics: [...context.diagnostics],
                };
                fixInfoDiagnostics.push(diagnostic);
                if (!whole) {
                    codeActions.push(action);
                }
            }
        }
        if (range.start.line === range.end.line && range.start.character === 0) {
            // <!-- markdownlint-disable-next-line -->
            const edit = coc_nvim_1.TextEdit.insert(coc_nvim_1.Position.create(range.start.line, 0), "<!-- markdownlint-disable-next-line -->\n");
            codeActions.push({
                title: "Disable markdownlint for current line",
                edit: {
                    changes: {
                        [doc.uri]: [edit],
                    },
                },
            });
        }
        if (whole) {
            // <!-- markdownlint-disable-file -->
            const edit = coc_nvim_1.TextEdit.insert(coc_nvim_1.Position.create(0, 0), "<!-- markdownlint-disable-file -->\n");
            codeActions.push({
                title: "Disable markdownlint for current file",
                edit: {
                    changes: {
                        [doc.uri]: [edit],
                    },
                },
            });
        }
        if (fixInfoDiagnostics.length) {
            const title = "Fix All error found by markdownlint";
            const sourceFixAllAction = {
                title,
                kind: coc_nvim_1.CodeActionKind.SourceFixAll,
                diagnostics: fixInfoDiagnostics,
                command: {
                    title,
                    command: this.fixAllCommandName,
                },
            };
            codeActions.push(sourceFixAllAction);
        }
        return codeActions;
    }
    lint(document) {
        if (document.languageId !== "markdown") {
            return;
        }
        this.diagnosticCollection.set(document.uri);
        const results = this.markdownlintWrapper(document);
        if (!results.length) {
            return;
        }
        const diagnostics = [];
        for (const result of results) {
            const ruleDescription = result.ruleDescription;
            let message = `${result.ruleNames.join("/")}: ${ruleDescription}`;
            if (result.errorDetail) {
                message += ` [${result.errorDetail}]`;
            }
            const start = coc_nvim_1.Position.create(result.lineNumber - 1, 0);
            const end = coc_nvim_1.Position.create(result.lineNumber - 1, 0);
            if (result.errorRange) {
                start.character = result.errorRange[0] - 1;
                end.character = start.character + result.errorRange[1];
            }
            const range = coc_nvim_1.Range.create(start, end);
            const diagnostic = coc_nvim_1.Diagnostic.create(range, message);
            diagnostic.severity = coc_nvim_1.DiagnosticSeverity.Warning;
            diagnostic.source = this.source;
            // @ts-ignore
            diagnostic.fixInfo = result.fixInfo;
            diagnostics.push(diagnostic);
        }
        this.diagnosticCollection.set(document.uri, diagnostics);
    }
    async fixAll(document) {
        const results = this.markdownlintWrapper(document);
        if (!results.length) {
            return;
        }
        const text = document.getText();
        const fixedText = (0, markdownlint_rule_helpers_1.applyFixes)(text, results);
        if (text !== fixedText) {
            const doc = coc_nvim_1.workspace.getDocument(document.uri);
            const end = coc_nvim_1.Position.create(doc.lineCount - 1, doc.getline(doc.lineCount - 1).length);
            const edit = {
                changes: {
                    [document.uri]: [coc_nvim_1.TextEdit.replace(coc_nvim_1.Range.create(coc_nvim_1.Position.create(0, 0), end), fixedText)],
                },
            };
            await coc_nvim_1.workspace.applyEdit(edit);
        }
    }
}
exports.MarkdownlintEngine = MarkdownlintEngine;
//# sourceMappingURL=engine.js.map