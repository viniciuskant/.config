"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.luaLsCommandAndArgs = exports.installLuaLs = exports.checkForUpdate = exports.osEnv = exports.install = void 0;
const tslib_1 = require("tslib");
const crypto = tslib_1.__importStar(require("crypto"));
const fs = tslib_1.__importStar(require("fs"));
const https = tslib_1.__importStar(require("https"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const tar = tslib_1.__importStar(require("tar"));
const coc_nvim_1 = require("coc.nvim");
const config_1 = require("./config");
const tools_1 = require("./tools");
const db_1 = require("./db");
const luaLsDir = "lua-language-server";
const oneDayMS = 24 * 60 * 60 * 1000;
const fsp = fs.promises;
const osPlatform = os.platform();
const tmpBaseDir = os.tmpdir();
const { join } = path;
const latestURL = 'https://api.github.com/repos/LuaLS/lua-language-server/releases/latest';
const pkg = JSON.parse(fs.readFileSync(path.join(__dirname, '../../package.json'), 'utf-8'));
const DBKey = {
    VERSION: 'installed-version',
    PUBLISHED_AT: 'installed-version-published-at',
    LAST_UPDATE_CHECK: "last-update-check",
};
function getLatestRelease(filePath) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { assets, tag_name: version, published_at } = yield getJSON(latestURL);
        const { browser_download_url: url } = (_a = assets.find(({ name }) => name.endsWith(filePath))) !== null && _a !== void 0 ? _a : {};
        return { version, publishedAt: new Date(published_at).getTime(), url };
    });
}
function getLatestVersion() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { tag_name: version, published_at } = yield getJSON(latestURL);
        return { version, publishedAt: new Date(published_at).getTime() };
    });
}
function install(dir) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { tarFile } = osEnv();
        const { url, version, publishedAt } = yield getLatestRelease(tarFile);
        yield downloadTar(url, dir);
        yield (0, db_1.dbSet)(DBKey.VERSION, version);
        yield (0, db_1.dbSet)(DBKey.PUBLISHED_AT, publishedAt);
    });
}
exports.install = install;
function downloadTar(sourceUrl, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const dir = yield mkTmpDir(sourceUrl);
        if (osPlatform === 'win32') {
            throw new Error('Windows is not currently supported');
        }
        else {
            const tarTmpPath = join(dir.path, "tmp.tar.gz");
            yield download(sourceUrl, tarTmpPath);
            yield tar.x({ file: tarTmpPath, cwd: targetPath, strip: 0 });
        }
        yield dir.dispose();
    });
}
function mkTmpDir(key) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const hash = crypto.createHash("md5").update(key).digest("hex");
        const dir = join(tmpBaseDir, hash);
        yield fsp.mkdir(dir, { recursive: true });
        return { path: dir, dispose: () => tslib_1.__awaiter(this, void 0, void 0, function* () { return fsp.rm(dir, { recursive: true }); }) };
    });
}
function download(sourceUrl, targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const file = fs.createWriteStream(targetPath);
        return new Promise((resolve, reject) => {
            const get = (url) => https.get(url, (res) => {
                const { statusCode } = res;
                if (statusCode === 301 || statusCode === 302) {
                    return get(res.headers.location);
                }
                res
                    .on("data", (data) => file.write(data))
                    .on("end", () => (file.end(), setTimeout(() => resolve(), 5)))
                    .on("error", (err) => reject(err));
            });
            return get(sourceUrl);
        });
    });
}
function osEnv() {
    switch (osPlatform) {
        case "darwin":
            return {
                tarFile: process.arch === 'arm64'
                    ? "darwin-arm64.tar.gz"
                    : "darwin-x64.tar.gz",
                bin: join("bin", "lua-language-server"),
            };
        case "linux":
            return {
                tarFile: process.arch === 'arm64'
                    ? "linux-arm64.tar.gz"
                    : "linux-x64.tar.gz",
                bin: join("bin", "lua-language-server"),
            };
        case "win32":
            return {
                tarFile: "win32-x64.zip",
                bin: join("bin", "lua-language-server.exe"),
            };
    }
    return { tarFile: "", bin: "" };
}
exports.osEnv = osEnv;
function checkForUpdate(action) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!(yield shouldCheck())) {
            return;
        }
        const statusItem = coc_nvim_1.window.createStatusBarItem(90, { progress: true });
        statusItem.text = "Check for updates";
        statusItem.show();
        try {
            const rinfo = (yield getLatestVersion());
            const linfo = yield (0, db_1.dbGet)(DBKey.PUBLISHED_AT);
            if (rinfo.publishedAt > linfo) {
                handleUpdateAction(action, rinfo.version);
            }
        }
        catch (err) {
            coc_nvim_1.window.showMessage(JSON.stringify(err), "error");
        }
        statusItem.hide();
    });
}
exports.checkForUpdate = checkForUpdate;
function shouldCheck() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const now = new Date().getTime();
        const last = yield (0, db_1.dbGet)(DBKey.LAST_UPDATE_CHECK, -1);
        const diff = now - last;
        if (last === -1 || diff > oneDayMS) {
            yield (0, db_1.dbSet)(DBKey.LAST_UPDATE_CHECK, now);
            return true;
        }
        return false;
    });
}
function handleUpdateAction(action, version) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        switch (action) {
            case "ask":
                if (yield coc_nvim_1.window.showPrompt(`LuaLS/lua-language-server ${version} is available. Install?`)) {
                    installLuaLs(true);
                }
                break;
            case "install":
                installLuaLs(true);
                break;
            case "inform":
                coc_nvim_1.window.showMessage(`LuaLS/lua-language-server ${version} is available. Run ":CocCommand lua.update"`);
                break;
        }
    });
}
function installLuaLs(force = false) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!force && (yield luaLsExists())) {
            return;
        }
        yield (0, tools_1.showInstallStatus)("LuaLS/lua-language-server", () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield install(yield (0, config_1.configDir)(luaLsDir));
        }));
    });
}
exports.installLuaLs = installLuaLs;
function luaLsCommandAndArgs() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const baseDir = yield (0, config_1.configDir)(luaLsDir);
        const { bin } = osEnv();
        return [path.join(baseDir, bin), ["-E", path.join(baseDir, "main.lua")]];
    });
}
exports.luaLsCommandAndArgs = luaLsCommandAndArgs;
function luaLsExists() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const [bin] = yield luaLsCommandAndArgs();
        return new Promise((resolve) => fs.open(bin, "r", (err) => resolve(err === null)));
    });
}
const getOptions = {
    headers: {
        'User-Agent': `coc-lua/${pkg.version}`,
    }
};
function getJSON(url) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            https
                .get(url, getOptions, (resp) => {
                let data = "";
                resp.on("data", (chunk) => (data += chunk));
                resp.on("end", () => {
                    resolve(JSON.parse(data));
                });
            })
                .on("error", (err) => reject(err));
        });
    });
}
//# sourceMappingURL=installer.js.map